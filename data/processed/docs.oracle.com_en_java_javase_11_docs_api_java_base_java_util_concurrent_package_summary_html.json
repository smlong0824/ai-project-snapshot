{
  "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
  "chunks": [
    {
      "content": "Utility classes commonly useful in concurrent programming. This package includes a few small standardized extensible frameworks, as well as some classes that provide useful functionality and are otherwise tedious or difficult to implement. Here are brief descriptions of the main components. See also the java.util.concurrent.locks and java.util.concurrent.atomic packages. Executors Interfaces. Executor is a simple standardized interface for defining custom thread-like subsystems, including thread pools, asynchronous I/O, and lightweight task frameworks. Depending on which concrete Executor class is being used, tasks may execute in a newly created thread, an existing task-execution thread, or the thread calling execute, and may execute sequentially or concurrently.",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_0",
        "chunk_index": 0
      }
    },
    {
      "content": "the thread calling execute, and may execute sequentially or concurrently. ExecutorService provides a more complete asynchronous task execution framework. An ExecutorService manages queuing and scheduling of tasks, and allows controlled shutdown. The ScheduledExecutorService subinterface and associated interfaces add support for delayed and periodic task execution. ExecutorServices provide methods arranging asynchronous execution of any function expressed as Callable, the result-bearing analog of Runnable. A Future returns the results of a function, allows determination of whether execution has completed, and provides a means to cancel execution. A RunnableFuture is a Future that possesses a run method that upon execution, sets its results. Implementations. Classes",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_1",
        "chunk_index": 1
      }
    },
    {
      "content": "run method that upon execution, sets its results. Implementations. Classes ThreadPoolExecutor and ScheduledThreadPoolExecutor provide tunable, flexible thread pools. The Executors class provides factory methods for the most common kinds and configurations of Executors, as well as a few utility methods for using them. Other utilities based on Executors include the concrete class FutureTask providing a common extensible implementation of Futures, and ExecutorCompletionService, that assists in coordinating the processing of groups of asynchronous tasks. Class ForkJoinPool provides an Executor primarily designed for processing instances of ForkJoinTask and its subclasses. These classes employ a work-stealing scheduler that attains high throughput for tasks conforming to",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_2",
        "chunk_index": 2
      }
    },
    {
      "content": "work-stealing scheduler that attains high throughput for tasks conforming to restrictions that often hold in computation-intensive parallel processing. Queues The ConcurrentLinkedQueue class supplies an efficient scalable thread-safe non-blocking FIFO queue. The ConcurrentLinkedDeque class is similar, but additionally supports the Deque interface. Five implementations in java.util.concurrent support the extended BlockingQueue interface, that defines blocking versions of put and take: LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue, PriorityBlockingQueue, and DelayQueue. The different classes cover the most common usage contexts for producer-consumer, messaging, parallel tasking, and related concurrent designs. Extended interface TransferQueue, and implementation LinkedTransferQueue introduce a synchronous transfer method (along with related features) in which a producer may",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_3",
        "chunk_index": 3
      }
    },
    {
      "content": "method (along with related features) in which a producer may optionally block awaiting its consumer. The BlockingDeque interface extends BlockingQueue to support both FIFO and LIFO (stack-based) operations. Class LinkedBlockingDeque provides an implementation. Timing The TimeUnit class provides multiple granularities (including nanoseconds) for specifying and controlling time-out based operations. Most classes in the package contain operations based on time-outs in addition to indefinite waits. In all cases that time-outs are used, the time-out specifies the minimum time that the method should wait before indicating that it timed-out. Implementations make a \"best effort\" to detect time-outs as soon as possible after they occur.",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_4",
        "chunk_index": 4
      }
    },
    {
      "content": "to detect time-outs as soon as possible after they occur. However, an indefinite amount of time may elapse between a time-out being detected and a thread actually executing again after that time-out. All methods that accept timeout parameters treat values less than or equal to zero to mean not to wait at all. To wait \"forever\", you can use a value of Long.MAX_VALUE. Synchronizers Five classes aid common special-purpose synchronization idioms. Semaphore is a classic concurrency tool. CountDownLatch is a very simple yet very common utility for blocking until a given number of signals, events, or conditions hold. A CyclicBarrier is a",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_5",
        "chunk_index": 5
      }
    },
    {
      "content": "of signals, events, or conditions hold. A CyclicBarrier is a resettable multiway synchronization point useful in some styles of parallel programming. A Phaser provides a more flexible form of barrier that may be used to control phased computation among multiple threads. An Exchanger allows two threads to exchange objects at a rendezvous point, and is useful in several pipeline designs. Concurrent Collections Besides Queues, this package supplies Collection implementations designed for use in multithreaded contexts: ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArrayList, and CopyOnWriteArraySet. When many threads are expected to access a given collection, a ConcurrentHashMap is normally preferable to a synchronized HashMap, and a",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_6",
        "chunk_index": 6
      }
    },
    {
      "content": "ConcurrentHashMap is normally preferable to a synchronized HashMap, and a ConcurrentSkipListMap is normally preferable to a synchronized TreeMap. A CopyOnWriteArrayList is preferable to a synchronized ArrayList when the expected number of reads and traversals greatly outnumber the number of updates to a list. The \"Concurrent\" prefix used with some classes in this package is a shorthand indicating several differences from similar \"synchronized\" classes. For example java.util.Hashtable and Collections.synchronizedMap(new HashMap()) are synchronized. But ConcurrentHashMap is \"concurrent\". A concurrent collection is thread-safe, but not governed by a single exclusion lock. In the particular case of ConcurrentHashMap, it safely permits any number of concurrent reads",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_7",
        "chunk_index": 7
      }
    },
    {
      "content": "of ConcurrentHashMap, it safely permits any number of concurrent reads as well as a large number of concurrent writes. \"Synchronized\" classes can be useful when you need to prevent all access to a collection via a single lock, at the expense of poorer scalability. In other cases in which multiple threads are expected to access a common collection, \"concurrent\" versions are normally preferable. And unsynchronized collections are preferable when either collections are unshared, or are accessible only when holding other locks. Most concurrent Collection implementations (including most Queues) also differ from the usual java.util conventions in that their Iterators and Spliterators provide",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_8",
        "chunk_index": 8
      }
    },
    {
      "content": "usual java.util conventions in that their Iterators and Spliterators provide weakly consistent rather than fast-fail traversal: they may proceed concurrently with other operations they will never throw ConcurrentModificationException they are guaranteed to traverse elements as they existed upon construction exactly once, and may (but are not guaranteed to) reflect any modifications subsequent to construction. Memory Consistency Properties Chapter 17 of The Java\u2122 Language Specification defines the happens-before relation on memory operations such as reads and writes of shared variables. The results of a write by one thread are guaranteed to be visible to a read by another thread only if the write",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_9",
        "chunk_index": 9
      }
    },
    {
      "content": "to a read by another thread only if the write operation happens-before the read operation. The synchronized and volatile constructs, as well as the Thread.start() and Thread.join() methods, can form happens-before relationships. In particular: Each action in a thread happens-before every action in that thread that comes later in the program's order. An unlock (synchronized block or method exit) of a monitor happens-before every subsequent lock (synchronized block or method entry) of that same monitor. And because the happens-before relation is transitive, all actions of a thread prior to unlocking happen-before all actions subsequent to any thread locking that monitor. A write",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_10",
        "chunk_index": 10
      }
    },
    {
      "content": "actions subsequent to any thread locking that monitor. A write to a volatile field happens-before every subsequent read of that same field. Writes and reads of volatile fields have similar memory consistency effects as entering and exiting monitors, but do not entail mutual exclusion locking. A call to start on a thread happens-before any action in the started thread. All actions in a thread happen-before any other thread successfully returns from a join on that thread. The methods of all classes in java.util.concurrent and its subpackages extend these guarantees to higher-level synchronization. In particular: Actions in a thread prior to placing an",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_11",
        "chunk_index": 11
      }
    },
    {
      "content": "In particular: Actions in a thread prior to placing an object into any concurrent collection happen-before actions subsequent to the access or removal of that element from the collection in another thread. Actions in a thread prior to the submission of a Runnable to an Executor happen-before its execution begins. Similarly for Callables submitted to an ExecutorService. Actions taken by the asynchronous computation represented by a Future happen-before actions subsequent to the retrieval of the result via Future.get() in another thread. Actions prior to \"releasing\" synchronizer methods such as Lock.unlock, Semaphore.release, and CountDownLatch.countDown happen-before actions subsequent to a successful \"acquiring\" method such",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_12",
        "chunk_index": 12
      }
    },
    {
      "content": "CountDownLatch.countDown happen-before actions subsequent to a successful \"acquiring\" method such as Lock.lock, Semaphore.acquire, Condition.await, and CountDownLatch.await on the same synchronizer object in another thread. For each pair of threads that successfully exchange objects via an Exchanger, actions prior to the exchange() in each thread happen-before those subsequent to the corresponding exchange() in another thread. Actions prior to calling CyclicBarrier.await and Phaser.awaitAdvance (as well as its variants) happen-before actions performed by the barrier action, and actions performed by the barrier action happen-before actions subsequent to a successful return from the corresponding await in other threads.",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_13",
        "chunk_index": 13
      }
    },
    {
      "content": "other threads.",
      "metadata": {
        "source": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/package-summary.html",
        "doc_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html",
        "category": "programming",
        "chunk_id": "docs.oracle.com_en_java_javase_11_docs_api_java_base_java_util_concurrent_package_summary_html_chunk_14",
        "chunk_index": 14
      }
    }
  ]
}